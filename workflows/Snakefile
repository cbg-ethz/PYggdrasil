"""Snakemake file defining the workflows"""

import json
import logging

import pyggdrasil as yg

from pathlib import Path

from pyggdrasil.tree_inference import McmcConfig, MoveProbConfig, MoveProbConfigOptions, McmcConfigOptions

################################################################################
# Imports
include: "visualize.smk"
################################################################################


# mock data parameters
params_md = dict()
params_md["seed"] = [32]
params_md["n_tree"] = 3
params_md["n_cells"] = 500
params_md["n_mutations"] = 8
params_md["strategy"] = ["""UNIFORM_INCLUDE_ROOT""", """UNIFORM_EXCLUDE_ROOT"""]
params_md["fpr"] = 1.24*10**(-6)
params_md["fnr"] = 0.097
params_md["na_rate"] = 0.014
params_md["observe_homozygous"] = ["False", "True"]

# MCMC parameters of mark00
params_mcmc = dict()
params_mcmc["seed"] = 42
params_mcmc["n_trees"] = 1
params_mcmc["n_cells"] = 2000
params_mcmc["n_mutations"] = 50
params_mcmc["strategy"] = """UNIFORM_INCLUDE_ROOT"""
params_mcmc["fpr"] = 1.24*10**(-6)
params_mcmc["fnr"] = 0.097
params_mcmc["na_rate"] = 0.014
params_mcmc["observe_homozygous"] = "False"


rule all:
    """Run all."""
    input:
        mcmc_samples = "Test.json"

rule make_random_or_deep_tree:
    """Make a tree (TreeNode) of random/deep topology and save it as JSON."""
    input:
        script="../scripts/make_tree.py"

    wildcard_constraints:
        tree_type = "(r|d)"
    output:
        tree="../data/{experiment}/trees/T_{tree_type}_{n_nodes,\d+}_{tree_seed,\d+}.json"
    shell:
        """
        poetry run python {input.script} \
            --out_dir ../data/{wildcards.experiment}/trees \
            --seed {wildcards.tree_seed} \
            --n_nodes {wildcards.n_nodes} \
            --tree_type {wildcards.tree_type}
        """

rule make_star_tree:
    """"Make a tree (TreeNode) of star topology and save it as JSON."""
    input:
        script="../scripts/make_tree.py"
    output:
        tree="../data/{experiment}/trees/T_s_{n_nodes,\d+}.json"
    shell:
        """
        poetry run python {input.script} \
            --out_dir ../data/{wildcards.experiment}/trees \
            --n_nodes {wildcards.n_nodes} \
            --tree_type s
        """


rule gen_cell_simulation:
    """Generate a mutation matrix given a true tree and save to JSON."""
    input:
        script="../scripts/cell_simulation.py",
        true_tree = "../data/{experiment}/trees/{true_tree_id}.json"
    output:
        mutation_data = "../data/{experiment}/mutations/CS_{CS_seed,\d+}-{true_tree_id}-{n_cells,\d+}_{CS_fpr}_{CS_fnr}_{CS_na}_{observe_homozygous}_{cell_attachment_strategy}.json"
    shell:
        """
        poetry run python {input.script} \
        --seed {wildcards.CS_seed} \
        --true_tree_fp {input.true_tree} \
        --n_cells {wildcards.n_cells} \
        --fpr {wildcards.CS_fpr} \
        --fnr {wildcards.CS_fnr} \
        --na_rate {wildcards.CS_na} \
        --observe_homozygous {wildcards.observe_homozygous} \
        --strategy {wildcards.cell_attachment_strategy} \
        --out_dir ../data/{wildcards.experiment}/mutations \
        """


# choose the optimal move probabilities, by enums
#optimal_MP_conf = MoveProbConfigOptions.OPTIMAL


# Set the Model manually
#customMcmcConfig = McmcConfigOptions.TEST.value

rule make_mcmc_move_prob_config:
    """Make MCMC move probability config."""
    params:
        prune_and_reattach = "{prune_and_reattach}",
        swap_node_labels = "{swap_node_labels}",
        swap_subtrees = "{swap_subtrees}"
    wildcard_constraints:
        prune_and_reattach = "\d+\.\d+",
        swap_node_labels = "\d+\.\d+",
        swap_subtrees = "\d+\.\d+",
    output:
        mcmc_move_prob_config = "../data/{experiment}/mcmc/config/MPC_{prune_and_reattach}_{swap_node_labels}_{swap_subtrees}.json",
    run:
        # define the move probabilities manually
        custom_MP_conf = MoveProbConfig(
            prune_and_reattach=float(params.prune_and_reattach),
            swap_node_labels=float(params.swap_node_labels),
            swap_subtrees=float(params.swap_subtrees)
        )

        with open(output.mcmc_move_prob_config, "w") as f:
            json.dump(custom_MP_conf.dict(), f)



rule make_mcmc_config:
    """Make MCMC config."""
    params:
        fpr = "{mcmc_fpr}",
        fnr = "{mcmc_fnr}",
        n_samples = "{mcmc_n_samples}",
        burn_in = "{burn_in}",
        thinning = "{thinning}",
    wildcard_constraints:
        move_prob_config_id = "MPC.*",
        thinning = "\d+",
        burn_in = "\d+",
    input:
        mcmc_move_prob_config = "../data/{experiment}/mcmc/config/{move_prob_config_id}.json",
    output:
        mcmc_config = "../data/{experiment}/mcmc/config/MC_{mcmc_fpr}_{mcmc_fnr}_{mcmc_n_samples}_{burn_in}_{thinning}-{move_prob_config_id}.json",
    run:
        # load the move probabilities from the config file
        with open(input.mcmc_move_prob_config, "r") as f:
            move_prob_config = json.load(f)
        move_prob_config = MoveProbConfig(**move_prob_config)

        # define the move probabilities manually
        customMcmcConfig = McmcConfig(
            fpr=float(params.fpr),
            fnr=float(params.fnr),
            n_samples=int(params.n_samples),
            burn_in=int(params.burn_in),
            thinning=int(params.thinning),
            move_probs=move_prob_config
        )

        with open(output.mcmc_config, "w") as f:
            json.dump(customMcmcConfig.dict(), f)



rule mcmc:
    """"Run MCMC"""
    input:
        script = "../scripts/run_mcmc.py",
        mutation_data= "../data/{experiment}/mutations/{mutation_data_id}.json",
        init_tree = "../data/{experiment}/trees/{init_tree_id}.json",
        mcmc_config = "../data/{experiment}/mcmc/config/{mcmc_config_id}.json",
    wildcard_constraints:
        mcmc_config_id = "MC.*",
        init_tree_id = "T.*"
    output:
        mcmc_log = '../data/{experiment}/mcmc/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}.log',
        mcmc_samples = '../data/{experiment}/mcmc/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}.json',
    shell:
        """
        poetry run python {input.script} \
        --seed {wildcards.mcmc_seed} \
        --config_fp {input.mcmc_config} \
        --out_dir ../data/{wildcards.experiment}/mcmc \
        --data_fp {input.mutation_data} \
        --init_tree_fp {input.init_tree} 
        """


rule analyze_metric:
    """Analyze MCMC run with a metric taking a base tree and
     an MCMC sample as input i.e. all distances /similarity metrics.
     Note: this includes ``is_true_tree``."""
    input:
        mcmc_samples = '../data/{experiment}/mcmc/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}.json',
        base_tree = '../data/{experiment}/trees/{base_tree_id}.json'

    output:
        result = '../data/{experiment}/analysis/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}/{base_tree_id}/{metric}.json',
        log = '../data/{experiment}/analysis/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}/{base_tree_id}/{metric}.log'
    run:
        # Set up logging
        # if logfile does not exist, create it
        log_path = Path(output.log)
        log_path.unlink(missing_ok=True)
        log_path.touch()
        logging.basicConfig(filename=log_path,level=logging.INFO)

        # load the data
        mcmc_samples = yg.serialize.read_mcmc_samples(Path(input.mcmc_samples))
        mcmc_data = yg.analyze.to_pure_mcmc_data(mcmc_samples)
        logging.info(f"Loaded MCMC samples")
        # load the tree
        base_tree = yg.serialize.read_tree_node(Path(input.base_tree))
        logging.info(f"Loaded base tree: {input.base_tree}")
        # define metric
        metric = yg.analyze.Metrics.get(wildcards.metric)
        logging.info(f"Loaded metric: {metric}")
        # compute the metric
        iteration, result = yg.analyze.analyze_mcmc_run(mcmc_data, metric, base_tree)
        # write the result
        fp = Path(output.result)
        yg.serialize.save_metric_result(iteration, result, fp)
        logging.info(f"Saved result to {fp}")


rule get_log_probs:
    """Extract log probabilities from MCMC samples for ease of plotting / analysis."""
    input:
        mcmc_samples='../data/{experiment}/mcmc/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}.json',
    output:
        result = '../data/{experiment}/analysis/MCMC_{mcmc_seed,\d+}-{mutation_data_id}-i{init_tree_id}-{mcmc_config_id}/log_prob.json',
    run:
        # load the data
        mcmc_samples = yg.serialize.read_mcmc_samples(Path(input.mcmc_samples))
        mcmc_data = yg.analyze.to_pure_mcmc_data(mcmc_samples)

        # write the result
        fp = Path(output.result)

        # get log probs
        log_probs = mcmc_data.log_probabilities
        # convert log probs to list of float
        log_probs = [float(i) for i in log_probs]
        # get iteration
        iteration = mcmc_data.iterations
        # convert iterations of list of int
        iteration = [int(i) for i in iteration]

        # save
        yg.serialize.save_metric_result(iteration, log_probs, fp)

