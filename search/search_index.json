{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyggdrasil","title":"PYggdrasil","text":"<p>Python package for inference and analysis of mutation trees.</p> <p>PYggdrasil implements the Single Cell Inference of Tumor Evolution (SCITE) algorithm by Kuipers J et al. (2015).</p> <p>It was designed to quantify the MCMC exploration of tumour progression tree spaces, in particular to investigate Initialisation Strategies, Convergence Diagnostics, &amp; Multi-modalities.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>import pyggdrasil as yg\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>See Contributing Guidelines.</p>"},{"location":"#setting-up-the-repository","title":"Setting up the repository","text":"<p>To build the package and maintain dependencies, we use Poetry. In particular, it's good to install it and become familiar with its basic functionalities by reading the documentation. </p> <p>To set up the environment (together with development tools), run: <pre><code>$ poetry install --with dev\n$ poetry run pre-commit install\n</code></pre></p> <p>Then, you will be able to run tests: <pre><code>$ poetry run pytest\n</code></pre> ... or check the types: <pre><code>$ poetry run pyright\n</code></pre></p> <p>Alternatively, you may prefer to work with the right Python environment using: <pre><code>$ poetry shell\n$ pytest\n</code></pre></p>"},{"location":"#existing-code-quality-checks","title":"Existing code quality checks","text":"<p>The code quality checks run on GitHub can be seen in <code>.github/workflows/test.yml</code>.</p> <p>We are using:</p> <ul> <li>Ruff to lint the code.</li> <li>Black to format the code.</li> <li>Pyright to check the types.</li> <li>Pytest to run the unit tests.</li> <li>Interrogate to check the documentation.</li> </ul>"},{"location":"#workflow","title":"Workflow","text":"<p>We use Feature Branch Workflow, in which modifications of the code should happen via small pull requests.</p> <p>We recommend submitting small pull requests and starting with drafts outlining proposed changes.</p>"},{"location":"#code-organisation","title":"Code organisation","text":"<ul> <li>The package code is in <code>src/pyggdrasil/</code> and is partitioned into subpackages.</li> <li>The unit tests are in <code>tests/</code>, and the structure of this directory should reflect the one of the package.</li> <li>Experimental workflows are in <code>workflows/</code>, with a description of how to set up the Conda environment in <code>workflows/README.md</code></li> </ul>"},{"location":"#origin-authorship","title":"Origin &amp; Authorship","text":"<p>This package originates from Gordon J K\u00f6hn's MSc Thesis: Quantifying MCMC Exploration of Tumour Progression Tree Spaces in 2023 at ETH Z\u00fcrich. Pawe\u0142 Czy\u017c and Prof. Dr Niko Beerenwinkel supervised this project as part of the Computational Biology Group at the Department of Biosystems Science and Engineering.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your time to contribute to this project! Below we present some guidelines.</p>"},{"location":"contributing/#reporting-a-bug","title":"Reporting a bug","text":"<p>If you find a bug, please submit a new issue.</p> <p>To be able to reproduce a bug, we will usually need the following information:</p> <ul> <li>Versions of Python packages used (in particular version of this library).</li> <li>A minimal code snippet allowing us to reproduce the bug.</li> <li>What is the desired behaviour in the reported case?</li> <li>What is the actual behaviour?</li> </ul>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>Do:</p> <ul> <li>Do use Google Style Guide. We use black for code formatting.</li> <li>Do write unit tests. We use pytest.</li> <li>Do write docstrings. We use Material for Mkdocs to generate the documentation.</li> <li>Do write high-level documentation as examples and tutorials, illustrating introduced features.</li> <li>Do consider submitting a draft pull request with a description of proposed changes.</li> <li>Do check the Development section.</li> </ul> <p>Don't:</p> <ul> <li>Don't include license information. This project is MIT licensed and by submitting your pull request you implicitly and irrevocably agree to use this.</li> <li>Don't implement too many ideas in a single pull request. Multiple features should be implemented in separate pull requests.</li> </ul>"},{"location":"contributing/#development","title":"Development","text":""},{"location":"contributing/#workflow","title":"Workflow","text":"<p>We use Feature Branch Workflow, in which modifications of the code should happen via small pull requests.</p> <p>We recommend submitting small pull requests and starting with drafts outlining proposed changes.</p>"},{"location":"contributing/#installation-dependencies","title":"Installation &amp; dependencies","text":"<p>To install the repository together with the dependencies run: <pre><code>$ git clone git@github.com:cbg-ethz/PYggdrasil.git  # Clone the repository\n$ poetry install --with dev                         # Install the dependencies\n$ poetry run pre-commit install                     # Install pre-commit hooks\n$ poetry run pytest                                 # Check if unit tests are passing\n</code></pre></p>"},{"location":"contributing/#testing-checking","title":"Testing &amp; Checking","text":"<p>Then, you will be able to run tests: <pre><code>$ poetry run pytest\n</code></pre> ... or check the types: <pre><code>$ poetry run pyright\n</code></pre></p>"},{"location":"contributing/#existing-code-quality-checks","title":"Existing code quality checks","text":"<p>The code quality checks run during on GitHub can be seen in <code>.github/workflows/test.yml</code>.</p> <p>We are using:   - Ruff to lint the code.   - Black to format the code.   - Pyright to check the types.   - Pytest to run the unit tests.   - Interrogate to check the documentation.</p> <p>Alternatively, you may prefer to work with the right Python environment using: <pre><code>$ poetry shell\n$ pytest\n</code></pre></p>"},{"location":"contributing/#building-documentation-locally","title":"Building documentation locally","text":"<p>You can build the documentation on your machine using: <pre><code>$ poetry run mkdocs serve\n</code></pre> and opening the generated link using web browser.</p>"},{"location":"contributing/#code-organisation","title":"Code organisation","text":"<ul> <li>The package code is in <code>src/pyggdrasil/</code> and is partitioned into subpackages.</li> <li>The unit tests are in <code>tests/</code> and the structure of this directory should reflect the one of the package.</li> <li>Experimental workflows are in <code>workflows/</code>, with a description of how to set up the environment in <code>workflows/README.md</code></li> </ul>"},{"location":"api/","title":"API","text":"<ul> <li>Analyze provides analysis tools of tree samples and inference runs.</li> <li>Distances provides tree-tree distance and similarity measures.</li> <li>Interface provides dataclasses for processing MCMC data.</li> <li>Serialize contains utilities for serialization and  deserialization of trees, MCMC rus and analysis.</li> <li>Tree Inference implements the mutation tree infernce; scDNA mutation profiles synthesis.</li> <li>Visualize implements visualization of trees and MCMC runs and diagostics theirof.</li> </ul> <p>This package handels trees with Anytree, see our adaption in the class TreeNode below.  For the inference we convert trees to binary adjacency matrices see Tree Inference, for reasons of performance.</p>"},{"location":"api/#pyggdrasil.TreeNode","title":"<code>pyggdrasil.TreeNode</code>","text":"<p>             Bases: <code>Generic[NameType, DataType]</code>, <code>NodeMixin</code></p> <p>Tree node compatible with AnyTree. It can be annotated with the label type and the data type.</p> Attrs <p>name: identifier of the node (compatible with declared type) data: payload data parent: the node of the parent children: iterable with the children nodes</p>"},{"location":"api/#pyggdrasil.TreeNode.__init__","title":"<code>__init__(name, data=None, parent=None, children=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>NameType</code> <p>identifier of the node (compatible with declared type)</p> required <code>data</code> <code>DataType</code> <p>payload data</p> <code>None</code> <code>parent</code> <code>Optional[TreeNode]</code> <p>the node of the parent</p> <code>None</code> <code>children</code> <code>Optional[Iterable[TreeNode]]</code> <p>iterable with the children nodes</p> <code>None</code>"},{"location":"api/#pyggdrasil.TreeNode.__str__","title":"<code>__str__()</code>","text":"<p>Casts to str.</p>"},{"location":"api/#pyggdrasil.TreeNode.convert_anytree_to_treenode","title":"<code>convert_anytree_to_treenode(node)</code>  <code>staticmethod</code>","text":"<p>Converts an AnyTree node to a TreeNode.</p> <p>Ignores the data attribute TreeNode nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>AnyTree node to be converted</p> required <p>Returns:     TreeNode with the same topology as the AnyTree node</p>"},{"location":"api/#pyggdrasil.TreeNode.convert_to_anytree_node","title":"<code>convert_to_anytree_node(tree_node)</code>  <code>staticmethod</code>","text":"<p>Converts a TreeNode to an AnyTree node.</p>"},{"location":"api/#pyggdrasil.TreeNode.print_topo","title":"<code>print_topo()</code>","text":"<p>Prints the topology of the tree.</p>"},{"location":"api/#pyggdrasil.compare_trees","title":"<code>pyggdrasil.compare_trees(tree1, tree2)</code>","text":"<p>Compares two labeled rooted trees.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True iff the two labeled rooted trees have the same structure</p> Note <p>Assumes that labels in each tree is unique Pyright may throw a false positive error when passing a TreeNode</p>"},{"location":"api/analyze/","title":"Analyze","text":""},{"location":"api/analyze/#pyggdrasil.analyze.rhats","title":"<code>pyggdrasil.analyze.rhats(chains)</code>","text":"<p>Compute estimate of rank normalized split R-hat for a set of chains.</p> <p>Sometimes referred to as the potential scale reduction factor / Gelman-Rubin statistic.</p> <p>Used the \u201crank\u201d method recommended by Vehtari et al. (2019)</p> <p>The rank normalized R-hat diagnostic tests for lack of convergence by comparing the variance between multiple chains to the variance within each chain. If convergence has been achieved, the between-chain and within-chain variances should be identical.</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>ndarray</code> <p>array of arrays to calculate R-hat for     (minimum of 2 chains, minimum of 4 draws)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>R-hat for given chains from index 4 to length,</p> <code>ndarray</code> <p>returns list that is 4 shorter than the length of the chains</p> Note <ul> <li>May return NaN if the chains are too short and all values are the same</li> <li>May raise Out of memory error if the chains are too long, 100000 samples   still works, 1000000 does not - storing all truncated chains in memory    is too much even at 24 GB RAM ?!   TODO: find a way to calculate R-hat for longer chains</li> </ul>"},{"location":"api/analyze/#pyggdrasil.analyze.ess","title":"<code>pyggdrasil.analyze.ess(chains)</code>","text":"<p>Calculates the effective sample size of a set of chains.</p> <p>used the \u201cbulk\u201d method recommended by Vehtari et al. (2019) rank normalized draws are used to calculate the effective sample size</p> <p>chains: array of arrays to calculate ESS for         (minimum of 2 chains, minimum of 4 draws)</p> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>ess_bulk, ess_tail for given chains from index 4 to length,</p>"},{"location":"api/analyze/#pyggdrasil.analyze.Metrics","title":"<code>pyggdrasil.analyze.Metrics</code>","text":"<p>Metrics for comparing trees.</p> <p>Attributes:</p> Name Type Description <code>_METRICS</code> <code>Dict[str, Callable[[TreeNode, TreeNode], float]]</code> <p>Dictionary of metrics.</p>"},{"location":"api/analyze/#pyggdrasil.analyze.Metrics.get","title":"<code>get(metric)</code>  <code>staticmethod</code>","text":"<p>Return metric function.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>Name of metric.</p> required <p>Returns:</p> Type Description <code>Callable[[TreeNode, TreeNode], float]</code> <ul> <li>AD: Ancestor-Descendant Similarity; pyggdrasil.distances.AncestorDescendantSimilarity().calculate,</li> </ul> <code>Callable[[TreeNode, TreeNode], float]</code> <ul> <li>MP3: MP3 Similarity; pyggdrasil.distances.MP3Similarity().calculate,</li> </ul> <code>Callable[[TreeNode, TreeNode], float]</code> <ul> <li>TrueTree: True Tree Similarity; pyggdrasil.compare_trees</li> </ul> <code>Callable[[TreeNode, TreeNode], float]</code> <ul> <li>DL: Different Lineage Similarity; pyggdrasil.distances.DifferentLineageSimilarity().calculate,</li> </ul> <code>Callable[[TreeNode, TreeNode], float]</code> <ul> <li>MLTD: MLTD Similarity; pyggdrasil.distances.MLTDSimilarity().calculate,</li> </ul>"},{"location":"api/analyze/#pyggdrasil.analyze.to_pure_mcmc_data","title":"<code>pyggdrasil.analyze.to_pure_mcmc_data(mcmc_samples)</code>","text":"<p>Converts McmcRunData to PureMcmcData.</p> <p>Takes a list of MCMCSamples converts it into a xarray easy to plot.</p> <p>Parameters:</p> Name Type Description Default <code>mcmc_samples</code> <p>list[MCMCSample] - list of MCMC samples</p> required <p>Returns:     PureMcmcData</p>"},{"location":"api/analyze/#pyggdrasil.analyze.check_run_for_tree","title":"<code>pyggdrasil.analyze.check_run_for_tree(desired_tree, mcmc_samples)</code>","text":"<p>Check if a tree is in an MCMC run.</p> <p>Returns of list of tuples of (iteration, tree, log-probability), or False. Goes through entire chain to find all instances of the tree.</p> <p>Parameters:</p> Name Type Description Default <code>desired_tree</code> <p>Tree</p> required <code>mcmc_samples</code> <p>McmcRunData</p> required <p>Returns:     bool or list(tuple[int, Tree, float])</p>"},{"location":"api/analyze/#pyggdrasil.analyze.analyze_mcmc_run","title":"<code>pyggdrasil.analyze.analyze_mcmc_run(mcmc_data, metric, base_tree)</code>","text":"<p>Analyze a MCMC run.</p> <p>Parameters:</p> Name Type Description Default <code>mcmc_data</code> <p>PureMcmcData         MCMC run data to analyze of iteration no.,         tree, and log-probability</p> required <code>metric</code> <p>Callable[[TreeNode, TreeNode], float]          metric to apply to the trees.</p> required <code>base_tree</code> <p>TreeNode         Tree to compare all applicable metrics to.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int], list[float]</p> <code>list[float]</code> <p>Iteration number and results of the metric.</p>"},{"location":"api/distances/","title":"Distances","text":""},{"location":"api/distances/#pyggdrasil.distances.TreeDistance","title":"<code>pyggdrasil.distances.TreeDistance</code>","text":"<p>             Bases: <code>TreeSimilarityMeasure</code></p> <p>Interface for distance functions between the trees.</p> <p>The hyperparameters of the metric should be set at the class initialization stage, similarly as with models in SciKit-Learn.</p> Note <p>The distances between trees should be treated as tree dissimilarity measures, rather than mathematical metrics. For example, the triangle inequality does not need to hold.</p>"},{"location":"api/distances/#pyggdrasil.distances.TreeDistance.triangle_inequality","title":"<code>triangle_inequality()</code>","text":"<p>Returns <code>True</code> if the triangle inequality</p> <p>.. math::</p> <p>d(t_1, t_3) &lt;= d(t_1, t_2) + d(t_2, t_3)</p> <p>is known to hold for this distance.</p> Note <p>If it is not known whether the triangle inequality holds for a metric, <code>False</code> should be returned.</p>"},{"location":"api/distances/#pyggdrasil.distances.TreeSimilarity","title":"<code>pyggdrasil.distances.TreeSimilarity</code>","text":"<p>             Bases: <code>TreeSimilarityMeasure</code></p> <p>Interface for similarity functions between the trees.</p> <p>The hyperparameters should be set at the class initialization stage, similarly as with models in SciKit-Learn.</p>"},{"location":"api/distances/#pyggdrasil.distances.TreeSimilarityMeasure","title":"<code>pyggdrasil.distances.TreeSimilarityMeasure</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Interface for similarity or distance functions between the trees.</p> <p>The hyperparameters should be set at the class initialization stage, similarly as with models in SciKit-Learn.</p>"},{"location":"api/distances/#pyggdrasil.distances.TreeSimilarityMeasure.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>_IntegerTreeRoot</code> <p>root of the first tree. The nodes should be labeled with integers.</p> required <code>tree2</code> <code>_IntegerTreeRoot</code> <p>root of the second tree. The nodes should be labeled with integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.TreeSimilarityMeasure.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p>"},{"location":"api/distances/#pyggdrasil.distances.calculate_distance_matrix","title":"<code>pyggdrasil.distances.calculate_distance_matrix(trees1, trees2, /, *, distance)</code>","text":"<p>Calculates a cross-distance matrix <code>d[i, j] = distance(trees1[i], trees2[j])</code></p> <p>Parameters:</p> Name Type Description Default <code>trees1</code> <code>Sequence[_IntegerTreeRoot]</code> <p>sequence of trees in one set, length m</p> required <code>trees2</code> <code>Sequence[_IntegerTreeRoot]</code> <p>sequence of trees in the second set, length n</p> required <code>distance</code> <code>TreeSimilarityMeasure</code> <p>distance or similarity function</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>distance matrix, shape (m, n)</p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarity","title":"<code>pyggdrasil.distances.AncestorDescendantSimilarity</code>","text":"<p>             Bases: <code>TreeSimilarity</code></p> <p>Ancestor-descendant accuracy.</p> <ul> <li>Considers only ancestor-descendant relationships between mutation,</li> </ul> <p>i.e. excludes the root node. For an implementation with the root considered  see AncestorDescendantSimilarityInclRoot instead.</p> <p>Raises:</p> Type Description <code>DivisionByZeroError</code> <p>If first tree is a star tree. Fork of scPhylo's not updated yet. Happens as no pairs of ancestor-descendant nodes can be created, given root is not considered.</p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarity.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code> using <code>scphylo.tl.ad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>Node</code> <p>root of the first tree. The nodes should be labeled with integers.</p> required <code>tree2</code> <code>Node</code> <p>root of the second tree. The nodes should be labeled with integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarity.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p>"},{"location":"api/distances/#pyggdrasil.distances.MP3Similarity","title":"<code>pyggdrasil.distances.MP3Similarity</code>","text":"<p>             Bases: <code>TreeSimilarity</code></p> <p>MP3 similarity.</p>"},{"location":"api/distances/#pyggdrasil.distances.MP3Similarity.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code> using <code>scphulo.tl.mp3</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>Node</code> <p>root of the first tree. The nodes should be labeled with integers.</p> required <code>tree2</code> <code>Node</code> <p>root of the second tree. The nodes should be labeled with integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.MP3Similarity.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarityInclRoot","title":"<code>pyggdrasil.distances.AncestorDescendantSimilarityInclRoot</code>","text":"<p>             Bases: <code>TreeSimilarity</code></p> <p>Ancestor-descendant similarity, adopted from @laurabquintas / Laura Quintas</p> <p>Counts the root as a mutation, i.e. considers pairs of ancestor-descendant nodes between root and nodes - effectivly making comparisons if mutations exist in both trees. May lead a higher similarity score than AncestorDescendantSimilarity.</p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarityInclRoot.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code> using <code>scphylo.tl.ad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>Node</code> <p>root of the first tree. The nodes should be labeled with integers.</p> required <code>tree2</code> <code>Node</code> <p>root of the second tree. The nodes should be labeled with integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.AncestorDescendantSimilarityInclRoot.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p>"},{"location":"api/distances/#pyggdrasil.distances.DifferentLineageSimilarity","title":"<code>pyggdrasil.distances.DifferentLineageSimilarity</code>","text":"<p>             Bases: <code>TreeSimilarity</code></p> <p>Different-Lineage similarity.</p> <p>For each pair of mutations in ground truth tree that are in different-lineages relation we check whether the same relationship is preserved in the inferred tree.</p> <p>Similarity out of one.</p>"},{"location":"api/distances/#pyggdrasil.distances.DifferentLineageSimilarity.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code> using <code>scphulo.tl.dl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>Node</code> <p>root of the first tree. The nodes should be labeled with integers.    Considered the ground truth tree.</p> required <code>tree2</code> <code>Node</code> <p>root of the second tree. The nodes should be labeled with integers.    Considered the inferred tree to be compared to the ground truth.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.DifferentLineageSimilarity.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p> <p>Known to be asymmetric.</p>"},{"location":"api/distances/#pyggdrasil.distances.MLTDSimilarity","title":"<code>pyggdrasil.distances.MLTDSimilarity</code>","text":"<p>             Bases: <code>TreeSimilarity</code></p> <p>Multi-labeled tree dissimilarity measure (MLTD), normalized to [0,1].</p> <p>Similarity out of one.</p> <p>Raises: Segmentation faults sometimes, unknown why. - scyphylo's issue.</p>"},{"location":"api/distances/#pyggdrasil.distances.MLTDSimilarity.calculate","title":"<code>calculate(tree1, tree2)</code>","text":"<p>Calculates similarity between <code>tree1</code> and <code>tree2</code> using <code>scphulo.tl.dl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tree1</code> <code>Node</code> <p>root of the first tree. The nodes should be labeled with integers.</p> required <code>tree2</code> <code>Node</code> <p>root of the second tree. The nodes should be labeled with integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>similarity from <code>tree1</code> to <code>tree2</code></p>"},{"location":"api/distances/#pyggdrasil.distances.MLTDSimilarity.is_symmetric","title":"<code>is_symmetric()</code>","text":"<p>Returns <code>True</code> if the similarity function is symmetric, i.e., :math:<code>s(t_1, t_2) = s(t_2, t_1)</code> for all pairs of trees.</p> Note <p>If it is not known whether the similarity function is symmetric, <code>False</code> should be returned.</p> <p>Unknown, but probably not symmetric.</p>"},{"location":"api/interface/","title":"Interface","text":""},{"location":"api/interface/#pyggdrasil.interface.PureMcmcData","title":"<code>pyggdrasil.interface.PureMcmcData</code>  <code>dataclass</code>","text":"<p>Pure MCMC data</p> <p>Attributes:</p> Name Type Description <code>iterations</code> <code>Array</code> <p>jax.Array     iteration numbers</p> <code>trees</code> <code>list[TreeNode]</code> <p>list[TreeNode]     list of TreeNode objects</p> <code>log_probabilities</code> <code>Array</code> <p>jax.Array     log-probabilities of the trees</p>"},{"location":"api/interface/#pyggdrasil.interface.PureMcmcData.append","title":"<code>append(iteration, tree, log_probability, *args, **kwargs)</code>","text":"<p>Append a sample to the MCMC chain.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>int</code> <p>iteration number</p> required <code>tree</code> <code>TreeNode</code> <p>TreeNode object</p> required <code>log_probability</code> <code>float</code> <p>log-probability of the tree</p> required"},{"location":"api/interface/#pyggdrasil.interface.PureMcmcData.get_sample","title":"<code>get_sample(iteration)</code>","text":"<p>Return a sample from the MCMC chain.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>int</code> <p>iteration number</p> required <p>Returns:     tree: TreeNode object     log_probability: log-probability of the tree</p>"},{"location":"api/serialize/","title":"Serialize","text":""},{"location":"api/serialize/#pyggdrasil.serialize.serialize_tree_to_dict","title":"<code>pyggdrasil.serialize.serialize_tree_to_dict(tree_root, *, serialize_data, naming=None)</code>","text":"<p>Serializes a tree with data into a nested dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tree_root</code> <code>TreeNode[NameType, DataType]</code> <p>node representing the root of the tree to be serialized</p> required <code>serialize_data</code> <code>Callable[[DataType], Any]</code> <p>function serializing a <code>DataType</code> object</p> required <code>naming</code> <code>Optional[_NamingConvention]</code> <p>serialization naming conventions, non-default values are discouraged</p> <code>None</code> <p>Returns:</p> Type Description <code>DictSeralizedFormat</code> <p>dictionary storing the tree in the format:</p> <code>DictSeralizedFormat</code> <p>{ \"name\": \"Root name\", \"data\": [serialized root.data], \"children\": [     {         \"name\": \"Child name\",         \"data\": [serialized child.data],         \"children\": [             ...         ]     }     ... ]</p> <code>DictSeralizedFormat</code> <p>}</p>"},{"location":"api/serialize/#pyggdrasil.serialize.deserialize_tree_from_dict","title":"<code>pyggdrasil.serialize.deserialize_tree_from_dict(dct, *, deserialize_data, naming=None)</code>","text":"<p>Creates tree from dictionary in the <code>DictSerializedFormat</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dct</code> <code>DictSeralizedFormat</code> <p>dictionary to be read</p> required <code>deserialize_data</code> <code>Callable[[Any], DataType]</code> <p>factory method creating <code>DataType</code> objects from dictionaries</p> required <code>naming</code> <code>Optional[_NamingConvention]</code> <p>serialization naming conventions, non-default values are discouraged</p> <code>None</code> <p>Returns:</p> Type Description <code>TreeNode</code> <p>root node to the generated tree</p>"},{"location":"api/serialize/#pyggdrasil.serialize.read_mcmc_samples","title":"<code>pyggdrasil.serialize.read_mcmc_samples(fullpath)</code>","text":"<p>Reads in all MCMC samples from JSON file for a given run.</p> <p>Parameters:</p> Name Type Description Default <code>fullpath</code> <code>Path</code> <p>path to JSON file</p> required <p>Returns:</p> Type Description <code>list[MCMCSample]</code> <p>MCMC sample</p>"},{"location":"api/serialize/#pyggdrasil.serialize.save_mcmc_sample","title":"<code>pyggdrasil.serialize.save_mcmc_sample(sample, out_fp)</code>","text":"<p>Appends MCMC sample to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <code>MCMCSample</code> <p>MCMC sample to be saved</p> required <code>out_fp</code> <code>Path</code> <p>path to JSON file</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/serialize/#pyggdrasil.serialize.read_tree_node","title":"<code>pyggdrasil.serialize.read_tree_node(fp)</code>","text":"<p>Reads Json file to Tree object from disk.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Path</code> <p>directory to save tree to</p> required"},{"location":"api/serialize/#pyggdrasil.serialize.save_tree_node","title":"<code>pyggdrasil.serialize.save_tree_node(tree, output_fp)</code>","text":"<p>Saves Tree object as dict /json to disk.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>TreeNode</code> <p>Tree object to be saved</p> required <code>output_fp</code> <code>Path</code> <p>directory to save tree to</p> required <p>Returns:     None</p>"},{"location":"api/serialize/#pyggdrasil.serialize.save_metric_result","title":"<code>pyggdrasil.serialize.save_metric_result(axis, result, out_fp, axis_name='iteration')</code>","text":"<p>Appends metric result to JSON file.</p>"},{"location":"api/serialize/#pyggdrasil.serialize.read_metric_result","title":"<code>pyggdrasil.serialize.read_metric_result(fullpath)</code>","text":"<p>Reads in all metric results from JSON file for a given run.</p>"},{"location":"api/tree_inference/","title":"Tree Inference","text":""},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellAttachmentStrategy","title":"<code>pyggdrasil.tree_inference.CellAttachmentStrategy</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum representing valid strategies for attaching cells to the mutation tree.</p> Allowed values <ul> <li>UNIFORM_INCLUDE_ROOT: each node in the tree has equal probability     of being attached a cell</li> <li>UNIFORM_EXCLUDE_ROOT: each non-root node in the tree has equal probability     of being attached a cell</li> </ul>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationData","title":"<code>pyggdrasil.tree_inference.CellSimulationData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Data class for Cell Simulation Data.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationId","title":"<code>pyggdrasil.tree_inference.CellSimulationId</code>","text":"<p>             Bases: <code>MutationDataId</code></p> <p>Class representing a cell simulation id.</p> <p>Note: that the Tree_id contains the number of mutations i.e. nodes-1</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationId.__init__","title":"<code>__init__(seed, tree_id, n_cells, fpr, fnr, na_rate, observe_homozygous, strategy)</code>","text":"<p>Initializes a cell simulation id.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationId.from_str","title":"<code>from_str(str_id)</code>  <code>classmethod</code>","text":"<p>Creates a CellSimulation id from a string representation of the id. Args:     str_id: str</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel","title":"<code>pyggdrasil.tree_inference.CellSimulationModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model for Cell Simulation Parameters.</p> <p>Note: used in the simulation of cells and mutations gen_sim_data()</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel.realistic_cell_number","title":"<code>realistic_cell_number(v)</code>","text":"<p>Validate that the number of cells is realistic.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel.realistic_fnr","title":"<code>realistic_fnr(v)</code>","text":"<p>Validate that the false negative rate is realistic.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel.realistic_fpr","title":"<code>realistic_fpr(v)</code>","text":"<p>Validate that the false positive rate is realistic.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel.realistic_mutation_number","title":"<code>realistic_mutation_number(v)</code>","text":"<p>Validate that the number of mutations is realistic.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.CellSimulationModel.realistic_na_rate","title":"<code>realistic_na_rate(v)</code>","text":"<p>Validate that the NA rate is realistic.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.ErrorCombinations","title":"<code>pyggdrasil.tree_inference.ErrorCombinations</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Error Combinations for Cell Simulation and Tree Inference.</p> <p>Ideal: fpr=1e-6, fnr=1e-6 Typical: fpr=1e-6, fnr=0.1 Large: fpr=0.1, fnr=0.1 Extreme: fpr=0.3, fnr=0.3</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.ErrorRates","title":"<code>pyggdrasil.tree_inference.ErrorRates = tuple[float, float]</code>  <code>module-attribute</code>","text":""},{"location":"api/tree_inference/#pyggdrasil.tree_inference.evolve_tree_mcmc","title":"<code>pyggdrasil.tree_inference.evolve_tree_mcmc(init_tree, n_moves, rng, move_probs=MoveProbConfigOptions.DEFAULT.value)</code>","text":"<p>Evolves a tree using the SCITE MCMC moves, assumes default move weights.</p> <p>Parameters:</p> Name Type Description Default <code>init_tree</code> <code>TreeNode</code> <p>TreeNode tree to evolve</p> required <code>n_moves</code> <code>int</code> <p>int number of moves to perform</p> required <code>rng</code> <code>JAXRandomKey</code> <p>JAXRandomKey random number generator</p> required <code>move_probs</code> <code>MoveProbabilities</code> <p>MoveProbabilities move probabilities to use</p> <code>value</code> <p>Returns:</p> Name Type Description <code>tree_ev</code> <code>TreeNode</code> <p>TreeNode evolved tree</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.evolve_tree_mcmc_all","title":"<code>pyggdrasil.tree_inference.evolve_tree_mcmc_all(init_tree, n_moves, rng, move_probs=MoveProbConfigOptions.DEFAULT.value)</code>","text":"<p>Evolves a tree using the SCITE MCMC moves, assumes default move weights.</p> <p>Parameters:</p> Name Type Description Default <code>init_tree</code> <code>TreeNode</code> <p>TreeNode tree to evolve</p> required <code>n_moves</code> <code>int</code> <p>int number of moves to perform</p> required <code>rng</code> <code>JAXRandomKey</code> <p>JAXRandomKey random number generator</p> required <code>move_probs</code> <code>MoveProbabilities</code> <p>MoveProbabilities move probabilities to use</p> <code>value</code> <p>Returns:</p> Name Type Description <code>trees</code> <code>list[TreeNode]</code> <p>list[TreeNode] evolved trees in order of evolution</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.gen_sim_data","title":"<code>pyggdrasil.tree_inference.gen_sim_data(params, rng, tree_tn)</code>","text":"<p>Generates cell mutation matrix for one tree.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>CellSimulationModel</code> <p>TypedDict from parser of cell_simulation.py input parameters from parser for simulation</p> required <code>rng</code> <code>JAXRandomKey</code> <p>JAX random number generator</p> required <code>tree_tn</code> <code>TreeNode</code> <p>TreeNode tree to generate data for</p> required <p>Returns:     data: dict         data dictionary containing - serialised data for the tree:             adjacency_matrix - adjacency matrix of the tree             perfect_mutation_mat - perfect mutation matrix             noisy_mutation_mat - noisy mutation matrix                                 (only if fpr &gt; 0 | fnr &gt; 0 | na_rate &gt; 0)             root - root of the tree (TreeNode)</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.get_descendants","title":"<code>pyggdrasil.tree_inference.get_descendants(adj_matrix, labels, parent, include_parent=False)</code>","text":"<p>Returns a list of labels representing the descendants of node parent. Used boolean matrix exponentiation to find descendants.</p> Complexity <p>Naive: O(n^3 * (n-1)) where n is the number of nodes in the tree including root. TODO: - Consider implementing 'Exponentiation by Squaring Algorithm'             for  O(n^3 * log(m)       - fix conditional exponentiation for exponent &lt; n-1</p> <p>Args: - adj_matrix: a JAX array of shape (n, n) representing the adjacency matrix - labels: a JAX array of shape (n,) representing the labels of the nodes - parent: an integer representing     the label of the node whose descendants we want to find</p> <ul> <li>a JAX array of integers representing the labels of the descendants of node parent   in order of nodes in the adjacency matrix, i.e. the order of the labels   if includeParent is True, the parent is included in the list of descendants</li> </ul>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.get_simulation_data","title":"<code>pyggdrasil.tree_inference.get_simulation_data(data)</code>","text":"<p>Load the mutation matrix from json object of the simulation data output of cell_simulation.py</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>dict data dictionary containing - serialised data</p> required <p>Returns:</p> Type Description <code>CellSimulationData</code> <p>tuple of: adjacency_matrix: TreeAdjacencyMatrix     Adjacency matrix of the tree. perfect_mutation_mat: PerfectMutationMatrix     Perfect mutation matrix. noisy_mutation_mat: MutationMatrix     Noisy mutation matrix. May be none if cell simulation was errorless. root: TreeNode     Root of the tree.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.huntress_tree_inference","title":"<code>pyggdrasil.tree_inference.huntress_tree_inference(mutation_mat, false_positive_rate, false_negative_rate, n_threads=1)</code>","text":"<p>Runs the HUNTRESS algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>mutation_mat</code> <code>MutationMatrix</code> <p>binary array with entries 0 or 1, depending on whether the mutation is present or not. Shape (n_sites, n_cells)</p> required <code>false_positive_rate</code> <code>float</code> <p>false positive rate, in [0, 1)</p> required <code>false_negative_rate</code> <code>float</code> <p>false negative rate, in [0, 1)</p> required <code>n_threads</code> <code>int</code> <p>number of threads to be used, default 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Node</code> <p>inferred tree. The root node (wildtype) has name <code>n_mutations</code> and the other nodes are named with integer labels using the mutation index (starting at 0)</p> Example <p>For a matrix of shape (n_cells, 4) an example tree can be 4 \u251c\u2500\u2500 0 \u2502   \u251c\u2500\u2500 1 \u2502   \u2514\u2500\u2500 2 \u2514\u2500\u2500 3</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.make_tree","title":"<code>pyggdrasil.tree_inference.make_tree(n_nodes, tree_type, seed=None)</code>","text":"<p>Generated basic Trees by parameters.</p> <p>Parameters:</p> Name Type Description Default <code>n_nodes</code> <code>int</code> <p>int number of nodes in the tree</p> required <code>tree_type</code> <code>TreeType</code> <p>TreeType type of the tree (STAR, RANDOM, DEEP)</p> required <code>seed</code> <code>Optional[int]</code> <p>int seed for the random number generator</p> <code>None</code> <p>Returns:     tree: TreeNode</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.McmcConfig","title":"<code>pyggdrasil.tree_inference.McmcConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Config for MCMC sampler.</p> <p>Attributes:</p> <pre><code>move_probs: MoveProbConfig\n    move probabilities for MCMC sampler\nfpr: float\n    false positive rate\nfnr: float\n    false negative rate\nn_samples: int\n    number of samples to draw\nburn_in: int\n    number of samples to discard as burn-in\nthinning: int\n    thinning factor for samples\n</code></pre>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.McmcConfig.id","title":"<code>id()</code>","text":"<p>String representation of MCMC config.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.McmcConfigOptions","title":"<code>pyggdrasil.tree_inference.McmcConfigOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>MCMC run configurations.</p> <p>Implements configurations are DEFAULT and TEST.</p> DEFAULT <p>move_probs=MoveProbConfigOptions.DEFAULT fpr=1.24e-06, fnr=0.097, n_samples=12000, burn_in=0, thinning=1</p> TEST <p>move_probs=MoveProbConfigOptions.DEFAULT fpr=1.24e-06, fnr=0.097, n_samples=100, burn_in=0, thinning=1</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.McmcRunId","title":"<code>pyggdrasil.tree_inference.McmcRunId</code>","text":"<p>Class representing an MCMC run id.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.McmcRunId.__init__","title":"<code>__init__(seed, data, init_tree_id, mcmc_config)</code>","text":"<p>Initializes an MCMC run id.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>int</p> required <code>data</code> <code>Union[CellSimulationId, MutationDataId]</code> <p>Union[CellSimulationId, MutationDataId]</p> required <code>init_tree_id</code> <code>TreeId</code> <p>TreeId</p> required <code>mcmc_config</code> <code>McmcConfig</code> <p>McmcConfig</p> required"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.mcmc_sampler","title":"<code>pyggdrasil.tree_inference.mcmc_sampler(rng_key, init_tree, error_rates, move_probs, data, num_samples, out_fp, num_burn_in=0, thinning=0, iteration=0)</code>","text":"<p>Sample mutation trees according to the SCITE model.</p> <p>Parameters:</p> Name Type Description Default <code>rng_key</code> <code>JAXRandomKey</code> <p>random key for the MCMC sampler</p> required <code>init_tree</code> <code>Tree</code> <p>initial tree to start the MCMC sampler from</p> required <code>error_rates</code> <code>ErrorRates</code> <p>heta = (\fpr, \fnr) error rates</p> required <code>move_probs</code> <code>MoveProbabilities</code> <p>probabilities for each move</p> required <code>data</code> <code>MutationMatrix</code> <p>observed mutation matrix to calculate the log-probability of, given current tree</p> required <code>num_samples</code> <code>int</code> <p>number of samples to return</p> required <code>out_fp</code> <code>Path</code> <p>fullpath to output file (excluding file extension)</p> required <code>num_burn_in</code> <code>int</code> <p>number of samples to discard before returning samples</p> <code>0</code> <code>thinning</code> <code>int</code> <p>number of samples to discard between samples</p> <code>0</code> <code>iteration</code> <code>int</code> <p>sample numer in chain, for restarting</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MoveProbabilities","title":"<code>pyggdrasil.tree_inference.MoveProbabilities</code>  <code>dataclass</code>","text":"<p>Move probabilities. The default values were taken from the paragraph Combining the three MCMC moves of page 14 of the SCITE paper supplement.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MoveProbConfig","title":"<code>pyggdrasil.tree_inference.MoveProbConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Move probabilities for MCMC sampler.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MoveProbConfig.id","title":"<code>id()</code>","text":"<p>String representation of move probabilities.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MoveProbConfig.move_prob_validator","title":"<code>move_prob_validator(field_values)</code>  <code>classmethod</code>","text":"<p>Probabilities sum to 1.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MoveProbConfigOptions","title":"<code>pyggdrasil.tree_inference.MoveProbConfigOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Move probability configurations.</p> <p>Implements configurations are DEFAULT and OPTIMAL from SCITE paper, supplement p.15.</p> Default values <p>prune_and_reattach=0.1, swap_node_labels=0.65, swap_subtrees=0.25</p> Optimal values <p>prune_and_reattach=0.55, swap_node_labels=0.4, swap_subtrees=0.05</p> <p>(<code>Optimal values find ML tree up to 2 or 3 times faster</code>)</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MutationDataId","title":"<code>pyggdrasil.tree_inference.MutationDataId</code>","text":"<p>Class representing a mutation data id.</p> <p>In case we want to infer a tree from real data, we need to provide a mutation data id.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MutationDataId.__init__","title":"<code>__init__(id)</code>","text":"<p>Initializes a mutation data id.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.MutationMatrix","title":"<code>pyggdrasil.tree_inference.MutationMatrix = Array</code>  <code>module-attribute</code>","text":""},{"location":"api/tree_inference/#pyggdrasil.tree_inference.Tree","title":"<code>pyggdrasil.tree_inference.Tree</code>  <code>dataclass</code>","text":"<p>For <code>N</code> mutations we use a tree with <code>N+1</code> nodes, where the nodes at positions <code>0, ..., N-1</code> are \"blank\" and can be mapped to any of the mutations. The node <code>N</code> is the root node and should always be mapped to the wild type.</p> Attrs <p>tree_topology: the topology of the tree   encoded in the adjacency matrix.   No self-loops, i.e. diagonal is all zeros.   Shape <code>(N+1, N+1)</code> labels: maps nodes in the tree topology   to the actual mutations.   Note: the last position always maps to itself,   as it's the root, and we use the convention   that root has the largest index.   Shape <code>(N+1,)</code></p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.Tree.print_topo","title":"<code>print_topo()</code>","text":"<p>Prints the tree in a human-readable format.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.Tree.to_TreeNode","title":"<code>to_TreeNode()</code>","text":"<p>Converts this Tree to a TreeNode. Returns the root node of the tree.</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.Tree.tree_from_tree_node","title":"<code>tree_from_tree_node(tree_node)</code>  <code>staticmethod</code>","text":"<p>Converts a tree node to a tree</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.TreeId","title":"<code>pyggdrasil.tree_inference.TreeId</code>","text":"<p>Class representing a tree id.</p> <p>A tree id is a unique identifier for a tree.</p> <p>tree_type: TreeType - type of tree n_nodes: int - number of nodes in the tree seed: int - seed used to generate the tree, not required for star tree cell_simulation_id: str - if the tree was generated from a cell                             simulation, i.e. Huntress</p>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.TreeId.__init__","title":"<code>__init__(tree_type, n_nodes, seed=None, cell_simulation_id=None)</code>","text":"<p>Initializes a tree id.</p> <p>Parameters:</p> Name Type Description Default <code>tree_type</code> <code>TreeType</code> <p>TreeType</p> required <code>n_nodes</code> <code>int</code> <p>int</p> required <code>seed</code> <code>Optional[int]</code> <p>int</p> <code>None</code>"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.TreeId.from_str","title":"<code>from_str(str_id)</code>  <code>classmethod</code>","text":"<p>Creates a tree id from a string representation of the id.</p> <p>Parameters:</p> Name Type Description Default <code>str_id</code> <code>str</code> <p>str</p> required"},{"location":"api/tree_inference/#pyggdrasil.tree_inference.TreeType","title":"<code>pyggdrasil.tree_inference.TreeType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum representing valid tree types implemented in pyggdrasil.</p> Allowed values <ul> <li>RANDOM (random tree)</li> <li>STAR (star tree)</li> <li>DEEP (deep tree)</li> <li>HUNTRESS (Huntress tree) - inferred from real / cell simulation data</li> <li>MCMC - generated tree evolve by MCMC moves</li> </ul>"},{"location":"api/visualize/","title":"Visualize","text":""},{"location":"api/visualize/#pyggdrasil.visualize.plot_tree","title":"<code>pyggdrasil.visualize.plot_tree(tree, save_name, save_dir, print_options, rename_labels=None)</code>","text":"<p>Plot a tree and save it to a file.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>TreeNode</code> <p>TreeNode tree to plot, given the root node     tree.data: may contain info to print for tree / node e.g.         \"log-likelihood\": float             likelihood of the tree     tree.name: name of tree, may use a title of plot</p> required <code>save_name</code> <code>str</code> <p>str name of the file to save the plot to</p> required <code>save_dir</code> <code>Path</code> <p>Path directory to save the plot to</p> required <code>print_options</code> <code>dict</code> <p>dict options for printing the tree     \"title\": bool         whether to print the name/title of the tree/root     \"data_tree\": dict         what attributes to print of the tree</p> required <code>rename_labels</code> <code>Optional[dict[str, NodeLabel]]</code> <p>dict dictionary of labels to rename     {0:1, 1:2, 3:\"IPC4\", 4:\"IPC5\"}     {old_label:new_label, ...}     pass empty dict to not rename labels</p> <code>None</code> <p>Returns:     None</p> Note <p>see tests/visualize/test_tree.py for example usage</p>"},{"location":"api/visualize/#pyggdrasil.visualize.save_metric_iteration","title":"<code>pyggdrasil.visualize.save_metric_iteration(iteration, distances, metric_name, out_fp)</code>","text":"<p>Save plot of distance to true tree vs iteration number to disk.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>list[int]</code> <p>list[int] Iteration numbers, 1-indexed.</p> required <code>out_fp</code> <code>Path</code> <p>Path Output file path.</p> required <code>distances</code> <code>list[float]</code> <p>ndarray Distances to true tree for each iteration.</p> required <code>metric_name</code> <code>str</code> <p>str Name of distance metric.</p> required"},{"location":"api/visualize/#pyggdrasil.visualize.save_log_p_iteration","title":"<code>pyggdrasil.visualize.save_log_p_iteration(iterations, log_probs, output_fp)</code>","text":"<p>Save plot of log probability vs iteration number to disk.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <p>Path Output directory to save the plot.</p> required <code>iterations</code> <code>list[int]</code> <p>list[int] Iteration numbers, 1-indexed.</p> required <code>log_probs</code> <code>list[float]</code> <p>list[float] Log probabilities.</p> required"},{"location":"api/visualize/#pyggdrasil.visualize.plot_tree_mcmc_sample","title":"<code>pyggdrasil.visualize.plot_tree_mcmc_sample(sample, save_dir, save_name='')</code>","text":"<p>Takes input of get_sample of PureMcmcData and , Plot a tree and save it to a file with just its iteration number and log probability, in the savename.</p>"},{"location":"api/visualize/#pyggdrasil.visualize.plot_tree_no_print","title":"<code>pyggdrasil.visualize.plot_tree_no_print(tree, save_name, save_dir)</code>","text":"<p>Takes input of get_sample of PureMcmcData and , Plot a tree and save it to a file with just its iteration  number and log probability, in the savename.</p>"},{"location":"api/visualize/#pyggdrasil.visualize.save_top_trees_plots","title":"<code>pyggdrasil.visualize.save_top_trees_plots(data, output_dir)</code>","text":"<p>Save plots of top three trees by log probability to disk,  with accompanying json to node the iterations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>mcmc samples</p> required <code>output_dir</code> <p>path to output directory</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Saves <p>top_tree_1.svg top_tree_2.svg top_tree_3.svg top_trees_iterations.json</p>"},{"location":"api/visualize/#pyggdrasil.visualize.save_rhat_iteration","title":"<code>pyggdrasil.visualize.save_rhat_iteration(iteration, rhats, out_fp)</code>","text":"<p>Save plot of rhat vs iteration number to disk.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>list[int]</code> <p>list[int] Iteration numbers.</p> required <code>out_fp</code> <code>Path</code> <p>Path Output file path.</p> required <code>rhats</code> <code>list[float]</code> <p>ndarray R hat values for each iteration.</p> required"},{"location":"api/visualize/#pyggdrasil.visualize.save_rhat_iteration_AD_DL","title":"<code>pyggdrasil.visualize.save_rhat_iteration_AD_DL(iteration, rhats_AD, rhats_DL, out_fp)</code>","text":"<p>Save plot of rhat vs iteration number to disk.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>list[int]</code> <p>list[int] Iteration numbers.</p> required <code>out_fp</code> <code>Path</code> <p>Path Output file path.</p> required <code>rhats_AD</code> <code>list[float]</code> <p>ndarray R hat values for each iteration for AD.</p> required <code>rhats_DL</code> <code>list[float]</code> <p>ndarray R hat values for each iteration for DL.</p> required"},{"location":"api/visualize/#pyggdrasil.visualize.save_ess_iteration_AD_DL","title":"<code>pyggdrasil.visualize.save_ess_iteration_AD_DL(iteration, ess_bulk_AD, ess_bulk_DL, ess_tail_AD, ess_tail_DL, out_fp)</code>","text":"<p>Save plot of ess vs iteration number to disk.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>list[int]</code> <p>list[int] Iteration numbers.</p> required <code>out_fp</code> <code>Path</code> <p>Path Output file path.</p> required <code>TODO</code> <p>add description</p> required"},{"location":"tutorial/","title":"Tutorials","text":"<p>We'd love to see you built upon PYggdrasil. Below, we provide some tutorials to help you get started.</p>"},{"location":"tutorial/#functional-usage","title":"Functional Usage","text":"<p>The tutorials below illustrate how to use PYggdrasil functions for specific tasks.</p> <ul> <li>Single MCMC Run demonstrates how to run a single MCMC chain.</li> <li>Tree Similarities and Visualization demonstrates how to compute distances between two trees and visualize trees.</li> <li>Analyzing MCMC Runs demonstrates how to compute distances between MCMC chains and diagnose convergence issues.</li> </ul>"},{"location":"tutorial/#experimental-workflows","title":"Experimental Workflows","text":"<p>We use snakemake to create a sustainable and reproducible workflow for extensive experiments with PYggdrasil. See Workflows for more details.</p> <p>The tutorials below illustrate snakemake workflows that allow running such fully reproducible experiments using PYggdrasil. From tree and data generation to convergence diagnostics, a pipeline exists.</p> <ul> <li>Basic Workflow demonstrates a basic workflow for a particular output file.</li> <li>Advanced Workflow demonstrates how to run a more advanced workflow. </li> </ul>"},{"location":"tutorial/advanced_workflow/","title":"Advanced Workflows","text":"<p>As part of my thesis at ETH Z\u00fcrich I, gordonkoehn, designed a series of advanced Snakemake workflows as reproducible experiments.</p> <p>We investigated particular aspects of SCITE\u2019s MCMC inference:</p> <ul> <li>warm-up of the MCMC chain</li> <li>multimodal posterior distributions</li> <li>convergence diagnsotics in the mutation tree space</li> </ul> <p>The workflows are available in:</p> <ul> <li> <p>mark01 : assessing the HUNTRESS trees with distance metrics under   the SCITE generative model</p> </li> <li> <p>mark02 : investigate convergence of SCITE MCMC chains, given   different initial points with tree distances.</p> </li> <li> <p>mark03 : investigate convergence of SCITE MCMC chains, given   different initial points with tree distances.</p> </li> <li> <p>mark04 : assessing the HUNTRESS trees with distance metrics under   the SCITE generative model.</p> </li> <li> <p>mark05 : assessing the MCMC tree dispersion per tree-tree metric as   a baseline to understand the tree-tree metric.</p> </li> </ul> <p>The outcome and analysis of the results are available in the thesis.</p>"},{"location":"tutorial/analyzeMCMC/","title":"Analyzing MCMC Runs","text":"<p>In this notebook we will analyze the samples of a MCMC.</p> <p>We analye the evolution of MCMC runs with tree similarities in combination with the Gelman-Rubin statistic.</p>"},{"location":"tutorial/analyzeMCMC/#imports","title":"Imports","text":"Code <pre><code>## imports\nimport pyggdrasil as yg\nimport jax.numpy as jnp\nimport numpy as np\nimport jax.random as random\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n# matplotlib inline\n%matplotlib inline \n</code></pre>"},{"location":"tutorial/analyzeMCMC/#run-mcmc","title":"Run MCMC","text":"<p>Below we run 4 Markov Chains, for 200 iterations each, with different initial trees.</p>"},{"location":"tutorial/analyzeMCMC/#generate-a-ground-truth-mutation-history-and-a-noisy-single-cell-mutation-profile","title":"Generate a ground-truth mutation history and a noisy single-cell mutation profile","text":"<p>The below cell generates a random tree with 4 mutations, plus root.</p> Code <pre><code># make true tree\ntree_type = yg.tree_inference.TreeType.RANDOM\nmutations = 10\nnodes = mutations + 1\ntree_seed = 42\ntrue_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed) \n</code></pre>"},{"location":"tutorial/analyzeMCMC/#generate-an-initial-tree-to-start-the-markov-chain-from","title":"Generate an initial tree to start the Markov Chain from","text":"<p>We also choose a random tree here.</p> Code <pre><code>inital_trees = []\ntree_type = yg.tree_inference.TreeType.RANDOM\nfor i in range(4):\n    tree_seed = i\n    inital_trees.append(yg.tree_inference.make_tree(nodes, tree_type, tree_seed))\n</code></pre>"},{"location":"tutorial/analyzeMCMC/#generate-a-noisy-single-cell-mutation-profile-from-the-ground-truth-tree","title":"Generate a noisy single-cell mutation profile from the ground-truth tree","text":"Code <pre><code>## generate some little nois data\n# Set up the simulation model\ncsm = yg.tree_inference.CellSimulationModel(\n    n_cells=1000,\n    n_mutations=mutations,\n    fpr=0.01,\n    fnr=0.2,\n    na_rate=0.0,\n    observe_homozygous=False,\n    strategy=yg.tree_inference.CellAttachmentStrategy.UNIFORM_EXCLUDE_ROOT,\n)\n\n\n# Generate Data\nseed = 42\nrng = random.PRNGKey(seed)\ndata = yg.tree_inference.gen_sim_data(\n    csm,\n    rng,\n    true_tree\n    )\n\nmut_mat = jnp.array(data['noisy_mutation_mat'])\n</code></pre>"},{"location":"tutorial/analyzeMCMC/#run-the-markov-monte-carlo-chain","title":"Run the Markov Monte Carlo Chain","text":"<p>The below cell runs a 4 differnt MCMC chain. We initialize it with the initial tree from before. We configure the move probabilities and error rates and run the MCMC chain for 200 iterations. The sampels are saved to disk and loaded back into memory as chains may be very long.</p> <pre><code>mcmc_datas = []\nn = 1\n# run 4 chains, each with a different initial tree\nfor starting_tree in inital_trees:\n        print(\"Starting MCMC for tree: \", n)\n        ## Run MCMC\n        # converting initial tree from TreeNode to Tree format\n        init_tree_t = yg.tree_inference.Tree.tree_from_tree_node(starting_tree)\n\n        ## file handling\n        # set up save location\n        save_dir = Path(\"\")\n        # make directory if it doesn't exist\n        save_dir.mkdir(parents=True, exist_ok=True)\n        save_name = \"mcmc_test\"\n        full_save_name = save_dir / f\"{save_name}.json\"\n\n        # make file / empty it if it exists\n        with open(full_save_name, \"w\") as f:\n            f.write(\"\")\n\n        # set the move probabilities and error rates\n        move_probs = yg.tree_inference.MoveProbabilities()\n        error_rates = yg.tree_inference.ErrorCombinations.IDEAL.value\n\n        # run mcmc sampler\n        yg.tree_inference.mcmc_sampler(\n            rng_key=rng,\n            data=mut_mat,\n            error_rates=(error_rates.fpr, error_rates.fnr),\n            move_probs=move_probs,\n            num_samples=200,\n            num_burn_in=0,\n            out_fp=full_save_name,\n            thinning=1,\n            init_tree=init_tree_t,\n        )\n\n        # load the data from disk\n        mcmc_data = yg.serialize.read_mcmc_samples(save_dir / f\"{save_name}.json\")\n        # append the data to the list\n        mcmc_datas.append(mcmc_data)\n        #delete file\n        (full_save_name).unlink()\n        print(\"finished MCMC\")\n        n += 1\n</code></pre> <pre><code>Starting MCMC for tree:  1\nfinished MCMC\nStarting MCMC for tree:  2\nfinished MCMC\nStarting MCMC for tree:  3\nfinished MCMC\nStarting MCMC for tree:  4\nfinished MCMC\n</code></pre> <pre><code># unpack the data - reads in the serialized trees to Tree objects\n# takes some time as tree objects are built and checked for validity\nfor i in range(len(mcmc_datas)):\n    mcmc_datas[i] = yg.analyze.to_pure_mcmc_data(mcmc_datas[i])\n</code></pre>"},{"location":"tutorial/analyzeMCMC/#lets-plot-the-log-probability-of-the-trees-over-the-iterations","title":"Let\u2019s plot the log-probability of the trees over the iterations","text":"<pre><code>for i in range(len(mcmc_datas)):\n    plt.plot(mcmc_datas[i].iterations, mcmc_datas[i].log_probabilities)\nplt.xlabel(\"Iteration\")\nplt.ylabel(\"Log-probability\")\nplt.grid()\nplt.show()\n</code></pre>"},{"location":"tutorial/analyzeMCMC/#lets-calculate-the-tree-similarity-over-the-iterations","title":"Let\u2019s calculate the tree similarity over the iterations","text":"<pre><code>metrics = [\"AD\",\"DL\"]\nbase_tree = true_tree\n# Create an empty list to store the results\nresults_AD = []\nresults_DL = []\nfor metric_name in metrics:\n    metric = yg.analyze.Metrics.get(metric_name)\n    for i in range(len(mcmc_datas)):\n        iteration, result = yg.analyze.analyze_mcmc_run(mcmc_datas[i], metric, base_tree)\n        # Append the result to the results list as a dictionary\n        if metric_name == \"AD\":\n            results_AD.append({\"Iteration\": iteration, \"Chain\": i, \"AD\": result})\n        elif metric_name == \"DL\":\n            results_DL.append({\"Iteration\": iteration, \"Chain\": i, \"DL\": result})\n# Convert the results list to a pandas DataFrame\nresults_AD = pd.DataFrame(results_AD)\nresults_DL = pd.DataFrame(results_DL)\n</code></pre> <p>Let\u2019s plot the tree similarity over the iterations</p> <pre><code># two subplots one for the AD and one for the DL\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfor i in range(len(mcmc_datas)):\n    axs[0].plot(results_AD[results_AD[\"Chain\"] == i][\"Iteration\"][i], results_AD[results_AD[\"Chain\"] == i][\"AD\"][i], label=f\"Chain {i}\")\n    axs[1].plot(results_DL[results_DL[\"Chain\"] == i][\"Iteration\"][i], results_DL[results_DL[\"Chain\"] == i][\"DL\"][i], label=f\"Chain {i}\")\naxs[0].set_xlabel(\"Iteration\")\naxs[0].set_ylabel(\"AD\")\naxs[0].grid()\naxs[0].legend()\naxs[1].set_xlabel(\"Iteration\")\naxs[1].set_ylabel(\"DL\")\naxs[1].grid()\naxs[1].legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorial/analyzeMCMC/#lets-calculate-the-gelman-rubin-statistic-over-the-iterations","title":"Let\u2019s calculate the Gelman-Rubin statistic over the iterations","text":"<pre><code># notably this code is rather poor, but you get the usage of the api\nrhat_AD = []\nrhat_DL = []\nfor metric_name in metrics:\n    # Append the result to the results list as a dictionary\n    if metric_name == \"AD\":\n        # calculate rhat - returns the 4-length array of rhats\n        chains = np.array(results_AD[metric_name])\n        rhat = yg.analyze.rhats(chains)\n        rhat_AD.append(rhat)\n    elif metric_name == \"DL\":\n        # calculate rhat - returns the 4-length array of rhats\n        chains = np.array(results_DL[metric_name])\n        rhat = yg.analyze.rhats(chains)\n        rhat_DL.append(rhat)\n</code></pre> Code <pre><code># two subplots one for the AD and one for the DL\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfor i in range(len(mcmc_datas)):\n    axs[0].plot(np.arange(1,len(rhat_DL[0])+1,1), rhat_AD[0])\n    axs[1].plot(np.arange(1,len(rhat_DL[0])+1,1), rhat_DL[0])\n    # make horizontal lines at 1.1\n    axs[0].axhline(y=1.1, color='r', linestyle='-')\n    axs[1].axhline(y=1.1, color='r', linestyle='-')\naxs[0].set_xlabel(\"Iteration\")\naxs[0].set_ylabel(\"AD\")\naxs[0].grid()\naxs[1].set_xlabel(\"Iteration\")\naxs[1].set_ylabel(\"DL\")\naxs[1].grid()\naxs[1].legend()\nplt.title(\"Gelman-Rubin statistic on the Tree Similarity\")\nplt.show()\n</code></pre> <p>We see that for these few iterations we do not achive approximate convergence defined to be below 1.1.</p> <p>The posterior is definitly not well explored yet.</p>"},{"location":"tutorial/analyzeMCMC/#lets-visualize-the-trees","title":"Let\u2019s visualize the trees","text":"<p>We visualize the posterior shape or in approximate terms the frequency of trees sampled over the tree similarities with respect to the true tree.</p> Code <pre><code># two subplots one for the AD and one for the DL\n# the tree similarities on the x-axis and chains in distinct colors\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfor i in range(len(mcmc_datas)):\n    axs[0].hist(results_AD[results_AD[\"Chain\"] == i][\"AD\"][i], label=f\"Chain {i}\", alpha=0.5)\n    axs[1].hist(results_DL[results_DL[\"Chain\"] == i][\"DL\"][i], label=f\"Chain {i}\", alpha=0.5)\naxs[0].set_xlabel(\"AD\")\naxs[0].set_ylabel(\"Frequency\")\naxs[0].grid()\naxs[0].legend()\naxs[1].set_xlabel(\"DL\")\naxs[1].set_ylabel(\"Frequency\")\naxs[1].grid()\naxs[1].legend()\nplt.show()\n</code></pre> <p></p> <p>We indeed see that the chains differ quite a lot. The chains are not well mixed yet. None of the chains agree on the shape of the posterior.</p>"},{"location":"tutorial/basicWorkflows/","title":"Basic Workflows","text":"<p>PYggdrasil implements several basic workflows for simulated mutation profile experiments.</p> <p>We originally used these workflows as part of larger experiments to evaluate SCITE\u2019s performance.</p> <p>Here, we show the workflow to run a SCITE mutation profile simulation and inference experiment. We visualize the evolution of the chains via the log probability and two similarity measures.</p> <p>In <code>workflows/</code>, we define several Snakemake workflows. These workflows are defined in a modular way so that they can be easily combined to create more complex workflows.</p> <ul> <li><code>workflows/tree_inference.smk</code> implements rules which run a mutation   profile simulation and inference experiment.</li> <li><code>workflows/anayze.smk</code> implements rules to analyze the results of a   simulation and inference experiment.</li> <li><code>workflows/visualize.smk</code> implements rules to visualize the results of   a simulation and inference experiment.</li> </ul> <p>All the <code>markXX</code> rules define more complex workflows using these basic functionalities. These experiments are defined in <code>workflows/markXX.smk</code> and are part of gordonkoehn\u2019s thesis.</p> <p>Here, we show how the basic workflows can work together to run a single MCMC chain and visualize the results. All workflow steps are designed to yield intermediate results saved to the disk. Each file is named uniquely to be easily identified and used in other workflows. A filename implies the complete history of its generation! (This results in long filenames but allows us to use pure string matching in snakemake \u2013 like magic.)</p>"},{"location":"tutorial/basicWorkflows/#run-a-single-mcmc-chain","title":"Run a single MCMC chain","text":"<p>Here is how you would run the mark04 workflow.</p> <pre><code> # navigate to the workflow directory\n cd workflows\n # run the mark00 workflow  with four cores\n snakemake -c 4 mark00\n</code></pre> <p>Note: before you can run it, you need to install snakemake at best in a conda environment. See workflows/README.md for more details.</p> <p>Also, you need to adjust the paths of the DATADIR and REPODIR in <code>workflows/mark00.smk_</code> and <code>workflows/tree_inference.smk</code>!</p> <p>Once you get it running, Here is what is happening; the diagram below shows the DAG of the mark00 workflow.</p> <p></p> <p>This graphic was generated by the following command:</p> <pre><code> snakemake --dag mark00 | dot -Tsvg &gt; mark00.svg\n</code></pre> <p>The core rules here are</p> <ul> <li>gen_cell_simulation to generate a simulated mutation profile given a   tree,</li> <li>mcmc running the inference and</li> <li>analyze_metrics to compute the similarity metrics.</li> </ul> <p>For the rest of the rules, see the individual files:</p> <ul> <li><code>workflows/tree_inference.smk</code></li> <li><code>workflows/analyze.smk</code></li> <li><code>workflows/visualize.smk</code></li> </ul> <p>The full workflow generated these three files:</p> <p></p> <p></p> <p>Note the AD is a bad metric to visualize here, as we use a star tree as a ground truth. No matter what the inference does, the AD will always be 0, as no ancestor-descendant relationship is present per the definition of a star tree.</p> <p></p>"},{"location":"tutorial/similarities/","title":"Tree Similarities","text":"<p>In this tutorial we generate a bunch of trees and compute their pairwise similarities and viszalize them.</p> <p>The visualizations are built with networkX and matplotlib. Quite some specification was done to make the visualizations look nice.</p> <p>Setting up the envrionment:</p> Code <pre><code>## imports\nimport pyggdrasil as yg\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n# matplotlib inline\n%matplotlib inline \n</code></pre>"},{"location":"tutorial/similarities/#generate-trees","title":"Generate trees","text":""},{"location":"tutorial/similarities/#random-tree","title":"Random Tree","text":"<pre><code>tree_type = yg.tree_inference.TreeType.RANDOM\ntree_seed = 487\nnodes = 10\nrandom_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed)\nrandom_tree.print_topo()\n</code></pre> <pre><code>9\n\u251c\u2500\u2500 6\n\u2502   \u251c\u2500\u2500 0\n\u2502   \u2514\u2500\u2500 3\n\u2514\u2500\u2500 8\n    \u251c\u2500\u2500 4\n    \u2502   \u2514\u2500\u2500 1\n    \u251c\u2500\u2500 5\n    \u2514\u2500\u2500 7\n        \u2514\u2500\u2500 2\n</code></pre> <p>Now let\u2019s visualize this properly.</p> <pre><code>save_dir = Path(\"tree_sim_figs\")\nsave_dir.mkdir(parents=True, exist_ok=True)\nsave_name = \"random_tree\"\nyg.visualize.plot_tree_no_print(random_tree, save_name, save_dir)\n</code></pre> <p></p>"},{"location":"tutorial/similarities/#star-tree","title":"Star Tree","text":"<pre><code>tree_type = yg.tree_inference.TreeType.STAR\ntree_seed = 487\nnodes = 10\nstar_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed)\n</code></pre> <p>Now let\u2019s visualize this properly.</p> Code <pre><code>save_name = \"star_tree\"\nyg.visualize.plot_tree_no_print(star_tree, save_name, save_dir)\n</code></pre> <p></p>"},{"location":"tutorial/similarities/#deep-tree","title":"Deep Tree","text":"<pre><code>tree_type = yg.tree_inference.TreeType.DEEP\ntree_seed = 487\nnodes = 10\ndeep_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed)\n</code></pre> <p>Now let\u2019s visualize this properly.</p> Code <pre><code>save_name = \"deep_tree\"\nyg.visualize.plot_tree_no_print(deep_tree, save_name, save_dir)\n</code></pre> <p></p> <p>Note: PYggdrasil inplements two more advanced tree generation methods.</p> <ol> <li>MCMC tree generation - takes a tree and evolves it by a fixed number     of random moves implemnted with SCITE.</li> <li>HUNTRESS inference - takes a cell-mutation profile and infers a tree     with HUNTRESS.</li> </ol>"},{"location":"tutorial/similarities/#compute-similarities","title":"Compute Similarities","text":"<p>What similarities to care for? We can compute the following similarities:</p> <ul> <li>Ancestor-Descendant (AD) Similarity</li> <li>Different-Lineage (DL) Similarity</li> </ul> <pre><code># random tree to star tree\nAD_star = yg.distances.AncestorDescendantSimilarity().calculate(random_tree, star_tree)\nDL_star = yg.distances.DifferentLineageSimilarity().calculate(random_tree, star_tree)\n\nprint(f\"AD Similarity: {AD_star}\")\nprint(f\"DL Similarity: {DL_star}\")\n</code></pre> <pre><code>AD Similarity: 0.0\nDL Similarity: 1.0\n</code></pre> <ul> <li>AD : 0.0 makes sense, since the star tree has no internal nodes, so no   nodes are ancestors of other nodes. (AD does not consider the root   node)</li> <li>DL : 1.0 makes sense, since the star tree has no internal nodes, so   all nodes are in different lineages.</li> </ul> Code <pre><code># random tree to deep tree\nAD_deep = yg.distances.AncestorDescendantSimilarity().calculate(random_tree, deep_tree)\nDL_deep = yg.distances.DifferentLineageSimilarity().calculate(random_tree, deep_tree)\n\nprint(f\"AD Similarity: {AD_deep}\")\nprint(f\"DL Similarity: {DL_deep}\")\n</code></pre> <pre><code>AD Similarity: 0.11111111111111116\nDL Similarity: 0.0\n</code></pre> <ul> <li>AD: some chronological order is preserved, but not all.</li> <li>DL: 0.0 makes sense, as all nodes are in the same lineage.</li> </ul> <p>Let\u2019s have another random tree for fun:</p> Code <pre><code>tree_type = yg.tree_inference.TreeType.RANDOM\ntree_seed = 4897\nnodes = 10\nrandom_tree2 = yg.tree_inference.make_tree(nodes, tree_type, tree_seed)\nsave_name = \"random_tree2\"\nyg.visualize.plot_tree_no_print(random_tree, save_name, save_dir)\n</code></pre> <p></p> Code <pre><code># random tree to another random tree\nAD_random = yg.distances.AncestorDescendantSimilarity().calculate(random_tree, random_tree2)\nDL_random = yg.distances.DifferentLineageSimilarity().calculate(random_tree, random_tree2)\n\nprint(f\"AD Similarity: {AD_random}\")\nprint(f\"DL Similarity: {DL_random}\")\n</code></pre> <pre><code>AD Similarity: 0.0\nDL Similarity: 0.8148148148148148\n</code></pre> <p>We see a more balanced mix of AD and DL similarities. Here by chance a AD of 0 again. Well, these are small trees.</p>"},{"location":"tutorial/singleMCMC/","title":"Single MCMC Run","text":"<p>This tutorial shows how to run a single MCMC chain of SCITE using PYggdrasil.</p> <ul> <li>We will generate our own ground-truth mutation history and generate a   noisy single-cell mutation profile from it.</li> <li>We will then run a single MCMC chain to infer the mutation history   from the noisy single-cell mutation profile.</li> <li>Visualize the results. The trees and the evolution of the MCMC.</li> </ul>"},{"location":"tutorial/singleMCMC/#0-imports","title":"0) Imports","text":"<pre><code>## imports\nimport pyggdrasil as yg\nimport jax.numpy as jnp\nimport jax.random as random\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n# matplotlib inline\n%matplotlib inline \n</code></pre>"},{"location":"tutorial/singleMCMC/#1-generate-a-ground-truth-mutation-history-and-a-noisy-single-cell-mutation-profile","title":"1) Generate a ground-truth mutation history and a noisy single-cell mutation profile","text":"<p>The below cell generates a random tree with 4 mutations, plus root. For debugging we may use the print_topo to plot its topology.</p> <pre><code># make true tree\ntree_type = yg.tree_inference.TreeType.RANDOM\nmutations = 4\nnodes = mutations + 1\ntree_seed = 42\ntrue_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed) \n\ntrue_tree.print_topo()\n</code></pre> <pre><code>4\n\u251c\u2500\u2500 0\n\u251c\u2500\u2500 2\n\u2502   \u2514\u2500\u2500 1\n\u2514\u2500\u2500 3\n</code></pre>"},{"location":"tutorial/singleMCMC/#2-generate-an-initial-tree-to-start-the-markov-chain-from","title":"2) Generate an initial tree to start the Markov Chain from","text":"<p>We also choose a random tree here.</p> <pre><code># make random starting tree\ntree_type = yg.tree_inference.TreeType.RANDOM\ntree_seed = 487\nstarting_tree = yg.tree_inference.make_tree(nodes, tree_type, tree_seed)\nstarting_tree.print_topo()\n</code></pre> <pre><code>4\n\u251c\u2500\u2500 1\n\u2514\u2500\u2500 3\n    \u251c\u2500\u2500 0\n    \u2514\u2500\u2500 2\n</code></pre>"},{"location":"tutorial/singleMCMC/#3-generate-a-noisy-single-cell-mutation-profile-from-the-ground-truth-tree","title":"3) Generate a noisy single-cell mutation profile from the ground-truth tree","text":"<pre><code>## generate some little nois data\n# Set up the simulation model\ncsm = yg.tree_inference.CellSimulationModel(\n    n_cells=1000,\n    n_mutations=mutations,\n    fpr=0.01,\n    fnr=0.01,\n    na_rate=0.0,\n    observe_homozygous=False,\n    strategy=yg.tree_inference.CellAttachmentStrategy.UNIFORM_EXCLUDE_ROOT,\n)\n\n\n# Generate Data\nseed = 42\nrng = random.PRNGKey(seed)\ndata = yg.tree_inference.gen_sim_data(\n    csm,\n    rng,\n    true_tree\n    )\n\nmut_mat = jnp.array(data['noisy_mutation_mat'])\nprint(mut_mat)\n</code></pre> <pre><code>[[0 0 0 ... 0 0 1]\n [1 0 0 ... 0 0 0]\n [1 1 1 ... 0 0 0]\n [0 0 0 ... 1 1 0]]\n</code></pre>"},{"location":"tutorial/singleMCMC/#4-run-the-markov-monte-carlo-chain","title":"4) Run the Markov Monte Carlo Chain","text":"<p>The below cell runs a single MCMC chain. We initialize it with the initial tree from before. We configure the move probabilities and error rates and run the MCMC chain for 100 iterations.  The samples are saved to disk and loaded back into memory as chains may be very long.</p> <pre><code>## Run MCMC\n# converting initial tree from TreeNode to Tree format\ninit_tree_t = yg.tree_inference.Tree.tree_from_tree_node(starting_tree)\n\n## file handling\n# set up save location\nsave_dir = Path(\"\")\n# make directory if it doesn't exist\nsave_dir.mkdir(parents=True, exist_ok=True)\nsave_name = \"mcmc_test\"\nfull_save_name = save_dir / f\"{save_name}.json\"\n# make file / empty it if it exists\nwith open(full_save_name, \"w\") as f:\n    f.write(\"\")\n\n# set the move probabilities and error rates\nmove_probs = yg.tree_inference.MoveProbabilities()\nerror_rates = yg.tree_inference.ErrorCombinations.IDEAL.value\n\n# run mcmc sampler\nyg.tree_inference.mcmc_sampler(\n    rng_key=rng,\n    data=mut_mat,\n    error_rates=(error_rates.fpr, error_rates.fnr),\n    move_probs=move_probs,\n    num_samples=100,\n    num_burn_in=0,\n    out_fp=full_save_name,\n    thinning=1,\n    init_tree=init_tree_t,\n)\n\n# load the data from disk\nmcmc_data = yg.serialize.read_mcmc_samples(save_dir / f\"{save_name}.json\")\n#delete file\n(full_save_name).unlink()\n</code></pre>"},{"location":"tutorial/singleMCMC/#5-visualize-the-results","title":"5) Visualize the results","text":"<p>In the following, we would like to plot the evolution of the MCMC chain and the trees that were sampled. First, we convert the data from the serialized format to a pureMCMCdata format. This is a simple data class that  contains the trees and the log probabilities of the trees.</p> <pre><code># unpack the data - reads in the serialized trees to Tree objects\n# takes some time as tree objects are built and checked for validity\nmcmc_samples = yg.analyze.to_pure_mcmc_data(mcmc_data)\n</code></pre> <p>Now, we may plot it.</p> <pre><code>plt.plot(mcmc_samples.iterations, mcmc_samples.log_probabilities)\nplt.xlabel(\"Iteration\")\nplt.ylabel(\"Log-probability\")\nplt.grid()\nplt.show()\n</code></pre> <p></p> <p>The log-probability quickly improved ! Seem like we have sampled a quicke good tree most of the time.</p> <p>Let\u2019s have a look at the last tree in the chain. The last tree appears to have a high log-probability.</p> <pre><code># get last tree\nlast_tree = mcmc_samples.trees[-1]\n# print topology\nlast_tree.print_topo()\n</code></pre> <pre><code>4\n\u251c\u2500\u2500 0\n\u251c\u2500\u2500 2\n\u2502   \u2514\u2500\u2500 1\n\u2514\u2500\u2500 3\n</code></pre> <p>Is it perhaps the true tree?</p> <pre><code># compare the true tree to the last tree\nyg.compare_trees(last_tree, true_tree)\n</code></pre> <pre><code>True\n</code></pre> <p>Now note that the last tree does not need to be a good tree. SCITE is just likely to spend more iterations exploring more likely trees. Here, the last tree just turns out to be a tree with the highest log-probability.</p> <p>To acutally retrive a mutation tree from the posterior one  would have to make a point estimate Maximum A Posteriori (MAP) tree,  i.e. sampled the most times.  See SCITE paper for details.</p>"},{"location":"workflows/","title":"Workflows","text":""},{"location":"workflows/#pyggdrasilworkflows","title":"PYggdrasil/workflows","text":"<p>Implements workflows to test and evaluate PYggdrasil using snakemake.</p>"},{"location":"workflows/#usage","title":"Usage","text":"<p>Before running any rules, set the <code>WORKDIR</code> in <code>Snakefile</code> and the path to the <code>PYggdrasil</code> package in the  <code>tree_inference.smk</code> file.</p> <p>Shared and experimental workflows are implemented. Shared workflows can be called upon by string matching i.e. <pre><code>    snakemake -c &lt;n_cores&gt; &lt;WORKDIR&gt;/&lt;EXPERIMENT&gt;/T_r_34_23.json\n</code></pre> which runs created a random Tree of 34 nodes and generation seed 23, see <code>tree_inference._file_id</code> for details. Where <code>&lt;n_cores&gt;</code> is the number of cores to use, and <code>&lt;WORKDIR&gt;/&lt;EXPERIMENT&gt;</code> is the directory of the output.</p> <p>Or run full experiments, titled m <code>markXX</code> by</p> <pre><code>    snakemake -c &lt;n_cores&gt; markXX \n</code></pre> <p>To inspect the DAG of the snakemake rule, e.g. <code>mark00</code>, run <pre><code>snakemake --dag mark00 | dot -Tpng &gt; dag.png\n</code></pre></p>"},{"location":"workflows/#environment","title":"Environment","text":"<p>Whilst we use Poetry as a dependency manager, we recommend to used Conda to as the environment manager.</p> <p>PYggdrasil's dependencies are best installed via Poetry in an envrioment created by Conda.</p> <p>This seperation allows to disect the dependencies of the package from the dependencies of the <code>workflows</code>, such as snakemake.</p> <p>We recommend a setup via <code>mini-conda.</code>, i.e on linux:</p> <p><pre><code>mkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\n~/miniconda3/bin/conda init bash\n~/miniconda3/bin/conda init zsh\n</code></pre> Note that the above installs miniconda in your home directory.</p> <p>Further, enhance by adding mamba to the conda environment, for faster resolving of dependencies: <pre><code>conda install mamba -n base -c conda-forge\n</code></pre></p> <p>Then, create a new environment for the project: <pre><code>cd PYggdrasil/\nmamba env create -f environment.yml\n</code></pre></p> <p>Then add in all project specific dependencies via: <pre><code>cd PYggdrasil/\nconda activate PYggdrasil\npip install -e .\n</code></pre> This should install all the dependencies, and make the package available in the environment <code>PYggdrasil</code> that is currently active by running the prior command.</p>"}]}